#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_ray_tracing_position_fetch        : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "merian-shaders/camera.glsl"
#include "merian-shaders/random.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/raytrace.glsl"
#include "merian-shaders/bsdf_diffuse.glsl"
#include "merian-shaders/grid.glsl"
#include "merian-shaders/color/colors_yuv.glsl"
#include "merian-shaders/color/colors_oklch.glsl"
#include "merian-shaders/hash.glsl"
#include "merian-shaders/bsdf_ggx.glsl"
#include "merian-shaders/bsdf_microfacet.glsl"
#include "merian-shaders/image_buffer.glsl.h"

#ifndef UPDATE_BUFFER_SIZE
#error "UPDATE_BUFFER_SIZE not defined"
#endif

#define ML_MIN_ALPHA .01
#define ML_MAX_N 1024s

uint rng_state;

#include "layout.glsl"
#include "mc.glsl"

#define pixel ivec2(gl_GlobalInvocationID)

//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void mc_update(inout MCState mc_state,
                         const vec3 pos,         // position where the ray started
                         const float w,          // goodness
                         const vec3 target, const f16vec3 mv) {    // ray hit point

    mc_state.N = min(mc_state.N + 1s, uint16_t(ML_MAX_N));
    const float alpha = max(1.0 / mc_state.N, ML_MIN_ALPHA);
   
    mc_state.sum_w = mix(mc_state.sum_w, w,          alpha);
    mc_state.w_tgt = mix(mc_state.w_tgt, w * target, alpha);
    mc_state.w_cos = min(mix(mc_state.w_cos, w * max(0, dot(normalize(target - pos), mc_state_dir(mc_state, pos))), alpha), mc_state.sum_w);

    mc_state.mv = mv;
}

void main() {
    #define update_buffer_idx gl_GlobalInvocationID.x
    if (update_buffer_idx >= UPDATE_BUFFER_SIZE) {
        return;
    }

    rng_state = pcg4d16(uvec4(pixel, params.frame, SEED));
    
    if(update_buffer[update_buffer_idx].update_count > 0) {
        MCUpdate update = update_buffer[update_buffer_idx];
        MCState mc_state = mc_states[update_buffer_idx];

        float sum = 0;
        vec3 pos = vec3(0);
        vec3 normal = vec3(0);
        MCState new_state;

        for (int i = 0; i < update.update_count; i++) {
            MCState state = mc_state;
            if (mc_state.id != update.ids[i]) {
                state = mc_state_new();
            }
            mc_update(state, update.positions[i], update.weights[i], update.targets[i], update.mv[i]);

            if(mc_state.id == state.id) {
                mc_state = state;
            }

            sum += state.sum_w;
            if(XorShift32(rng_state) < state.sum_w / sum) {
                new_state = state;
                pos = update.positions[i];
                normal = update.normals[i];
            }
        }

        new_state.T = update.T;

        for (int i = 0; i < update.update_count; i++) {
            // static save
            {
                uint buffer_index; uint16_t hash;
                mc_static_buffer_index(pos, buffer_index, hash);

                new_state.hash = hash;
                MCState old_state = mc_states[buffer_index];
                if(old_state.id == new_state.id || XorShift32(rng_state) < new_state.sum_w / (new_state.sum_w + old_state.sum_w)) {
                    mc_states[buffer_index] = new_state;
                }
            }
            //mc_static_save(new_state, pos, normal);

            // adaptive save
            {
                uint buffer_index; uint16_t hash;
                mc_adaptive_buffer_index(pos, normal, buffer_index, hash);

                new_state.hash = hash;
                MCState old_state = mc_states[buffer_index];
                if(old_state.id == new_state.id || XorShift32(rng_state) < new_state.sum_w / (new_state.sum_w + old_state.sum_w)) {
                    mc_states[buffer_index] = new_state;
                }
            }
        }

        update_buffer[update_buffer_idx].last_update_count = update.update_count;
        update_buffer[update_buffer_idx].update_count = 0;
    }
}