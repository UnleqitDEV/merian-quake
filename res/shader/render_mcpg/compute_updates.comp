#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_ray_tracing_position_fetch        : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "merian-shaders/camera.glsl"
#include "merian-shaders/random.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/raytrace.glsl"
#include "merian-shaders/bsdf_diffuse.glsl"
#include "merian-shaders/grid.glsl"
#include "merian-shaders/color/colors_yuv.glsl"
#include "merian-shaders/color/colors_oklch.glsl"
#include "merian-shaders/hash.glsl"
#include "merian-shaders/bsdf_ggx.glsl"
#include "merian-shaders/bsdf_microfacet.glsl"
#include "merian-shaders/image_buffer.glsl.h"

#ifndef UPDATE_BUFFER_SIZE
#error "UPDATE_BUFFER_SIZE not defined"
#endif

#define ML_MIN_ALPHA .01
#define ML_MAX_N 1024s

uint rng_state;

#include "layout.glsl"
#include "mc.glsl"

//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() {
    #define update_buffer_idx gl_GlobalInvocationID.x
    if (update_buffer_idx >= UPDATE_BUFFER_SIZE) {
        return;
    }

    if(update_buffer[update_buffer_idx].update_count > 0) {
        MCUpdate update = update_buffer[update_buffer_idx];
        MCState mc_state = mc_states[update_buffer_idx];
        rng_state = update.rng_state;

        mc_state.N = min(mc_state.N + uint16_t(update.update_count), uint16_t(ML_MAX_N));
        const float alpha = max(float(update.update_count) / float(mc_state.N), ML_MIN_ALPHA);
        
        float weight = update.weight / float(update.update_count);
        vec3 target = update.target / float(update.update_count);
        float cos = update.cos / float(update.update_count);
        vec3 normal = update.normal;
        vec3 pos = update.pos;

        mc_state.sum_w = mix(mc_state.sum_w, weight, alpha);
        mc_state.w_tgt = mix(mc_state.w_tgt, target, alpha);
        mc_state.w_cos = min(mix(mc_state.w_cos, cos, alpha), mc_state.sum_w);

        mc_state.mv = update.mv;
        mc_state.T = update.T;

        //mc_states[update_buffer_idx] = mc_state;
        mc_static_save(mc_state, pos, normal);
        mc_adaptive_save(mc_state, pos, normal);

        update_buffer[update_buffer_idx].last_update_count = update.update_count;
        update_buffer[update_buffer_idx].update_count = 0;
        update_buffer[update_buffer_idx].target = vec3(0);
        update_buffer[update_buffer_idx].weight = 0;
        update_buffer[update_buffer_idx].cos = 0;
    }
}