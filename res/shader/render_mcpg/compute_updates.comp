#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_ray_tracing_position_fetch        : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "merian-shaders/camera.glsl"
#include "merian-shaders/random.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/raytrace.glsl"
#include "merian-shaders/bsdf_diffuse.glsl"
#include "merian-shaders/grid.glsl"
#include "merian-shaders/color/colors_yuv.glsl"
#include "merian-shaders/color/colors_oklch.glsl"
#include "merian-shaders/hash.glsl"
#include "merian-shaders/bsdf_ggx.glsl"
#include "merian-shaders/bsdf_microfacet.glsl"
#include "merian-shaders/image_buffer.glsl.h"

#ifndef UPDATE_BUFFER_SIZE
#error "UPDATE_BUFFER_SIZE not defined"
#endif

#define buffer_idx gl_GlobalInvocationID.x
#define pixel ivec2(gl_GlobalInvocationID)
#define ML_MIN_ALPHA .01
#define ML_MAX_N 1024s

uint rng_state;

#include "layout.glsl"
#include "mc.glsl"

//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() {
    if (buffer_idx >= 32777259 + 800009) {
        return;
    }

    mc_states[buffer_idx].update_canceled = 100;

    //return;

    if(update_buffer[buffer_idx].update_count > 0) {
        mc_states[buffer_idx].update_succeeded = 100;

        return;
        MCUpdate update = update_buffer[buffer_idx];
        MCState mc_state = mc_states[buffer_idx];
        rng_state = update.rng_state;

        //mc_state.N = min(mc_state.N + uint16_t(update.update_count), uint16_t(ML_MAX_N));
        //const float alpha = max(float(update.update_count) / mc_state.N, ML_MIN_ALPHA);
        
        //float weight = update.weight / update.update_count;
        //vec3 target = update.target / update.update_count;
        //float cos = update.cos / update.update_count;

        mc_states[buffer_idx].N = min(mc_states[buffer_idx].N + 1s, uint16_t(ML_MAX_N));
        const float alpha = max(1.0 / mc_state.N, ML_MIN_ALPHA);

        float weight = update.weight;
        vec3 target = update.target;
        float cos = update.cos;

        mc_states[buffer_idx].sum_w = mix(mc_states[buffer_idx].sum_w, weight, alpha);
        mc_states[buffer_idx].w_tgt = mix(mc_states[buffer_idx].w_tgt, target, alpha);
        mc_states[buffer_idx].w_cos = min(mix(mc_states[buffer_idx].w_cos, cos, alpha), mc_state.sum_w);

        mc_states[buffer_idx].mv = update.mv;
        mc_states[buffer_idx].T = update.T;

        mc_states[buffer_idx] = mc_state;
        mc_static_save(mc_states[buffer_idx], update.pos, update.normal);
        mc_adaptive_save(mc_states[buffer_idx], update.pos, update.normal);

        update_buffer[buffer_idx].update_count = 0;
        //update_buffer[buffer_idx].target = vec3(0);
        //update_buffer[buffer_idx].weight = 0;
        //update_buffer[buffer_idx].cos = 0;
    }
}